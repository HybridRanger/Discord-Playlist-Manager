// src/SpotifyExtractor.ts
import { BaseExtractor, Playlist, Track, Util } from "discord-player";

// src/internal/spotify.ts
import { Secret, TOTP } from "otpauth";

// src/internal/helper.ts
var UA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.49";
var market = "";
var spotifyUrlRegex = /^(?:https:\/\/open\.spotify\.com\/(intl-([a-z]|[A-Z]){0,3}\/)?(?:user\/[A-Za-z0-9]+\/)?|spotify:)(album|playlist|track)(?:[/:])([A-Za-z0-9]+).*$/;
var spotifySongRegex = /^https?:\/\/(?:embed\.|open\.)(?:spotify\.com\/)(intl-([a-z]|[A-Z])+\/)?(?:track\/|\?uri=spotify:track:)((\w|-){22})(\?si=.+)?$/;
var spotifyPlaylistRegex = /^https?:\/\/(?:embed\.|open\.)(?:spotify\.com\/)(intl-([a-z]|[A-Z])+\/)?(?:playlist\/|\?uri=spotify:playlist:)((\w|-){22})(\?si=.+)?$/;
var spotifyAlbumRegex = /^https?:\/\/(?:embed\.|open\.)(?:spotify\.com\/)(intl-([a-z]|[A-Z])+\/)?(?:album\/|\?uri=spotify:album:)((\w|-){22})(\?si=.+)?$/;
var isUrl = (query) => {
  try {
    return ["http:", "https:"].includes(new URL(query).protocol);
  } catch {
    return false;
  }
};
var parseSpotifyUrl = (q) => {
  const [, , , queryType, id] = spotifyUrlRegex.exec(q) || [];
  return { queryType, id };
};

// src/internal/spotify.ts
import { parse } from "node-html-parser";
import { Buffer } from "node:buffer";
var SP_BASE = "https://api.spotify.com/v1";
var SpotifyAPI = class {
  constructor(credentials) {
    this.accessToken = null;
    this.useCredentials = false;
    if (credentials.clientId && credentials.clientSecret) {
      this.useCredentials = true;
      this.clientId = credentials.clientId;
      this.clientSecret = credentials.clientSecret;
    }
    this.market = credentials.market || market;
  }
  get authorizationKey() {
    return Buffer.from(`${this.clientId}:${this.clientSecret}`).toString("base64");
  }
  async requestToken() {
    try {
      const accessTokenUrl = await this.getAccessTokenUrl();
      const fetchOptions = !this.useCredentials ? {
        headers: {
          Referer: "https://open.spotify.com/",
          Origin: "https://open.spotify.com"
        }
      } : {
        method: "POST",
        headers: {
          "User-Agent": UA,
          Authorization: `Basic ${this.authorizationKey}`,
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: "grant_type=client_credentials"
      };
      const tokenData = await fetch(accessTokenUrl, fetchOptions).then((v) => v.json());
      if (!tokenData) throw new Error("Failed to retrieve access token.");
      this.accessToken = {
        token: !this.useCredentials ? tokenData.accessToken : tokenData.access_token,
        expiresAfter: !this.useCredentials ? tokenData.accessTokenExpirationTimestampMs : Date.now() + tokenData.expires_in * 1e3,
        type: "Bearer"
      };
    } catch (error) {
      console.error("Error requesting Spotify access token:", error);
      throw error;
    }
  }
  isTokenExpired() {
    return !this.accessToken || Date.now() > this.accessToken.expiresAfter;
  }
  async ensureValidToken() {
    if (this.isTokenExpired()) await this.requestToken();
  }
  async fetchData(apiUrl) {
    await this.ensureValidToken();
    const res = await fetch(apiUrl, {
      headers: {
        Authorization: `Bearer ${this.accessToken?.token}`,
        Referer: "https://open.spotify.com/",
        Origin: "https://open.spotify.com"
      }
    });
    if (!res.ok) throw new Error("Failed to fetch Spotify data.");
    return res;
  }
  async search(query) {
    try {
      const res = await this.fetchData(`${SP_BASE}/search/?q=${encodeURIComponent(query)}&type=track${this.market ? `&market=${this.market}` : ""}`);
      const data = await res.json();
      return data.tracks.items.map((m) => ({
        title: m.name,
        duration: m.duration_ms,
        artist: m.artists.map((artist) => artist.name).join(", "),
        url: m.external_urls?.spotify || `https://open.spotify.com/track/${m.id}`,
        thumbnail: m.album.images?.[0]?.url || null
      }));
    } catch {
      return null;
    }
  }
  async getPlaylist(id) {
    try {
      const res = await this.fetchData(`${SP_BASE}/playlists/${id}${this.market ? `?market=${this.market}` : ""}`);
      if (!res) return null;
      const data = await res.json();
      if (!data.tracks.items.length) return null;
      const t = data.tracks.items;
      let next = data.tracks.next;
      while (typeof next === "string") {
        try {
          const nextRes = await this.fetchData(next);
          if (!nextRes) break;
          const nextPage = await nextRes.json();
          t.push(...nextPage.items);
          next = nextPage.next;
          if (!next) break;
        } catch {
          break;
        }
      }
      const tracks = t.filter(({ track: m }) => m?.name && m?.artists).map(({ track: m }) => ({
        name: m.name,
        duration_ms: m.duration_ms,
        artists: m.artists,
        external_urls: m.external_urls,
        id: m.id,
        album: {
          images: m.album.images
        }
      }));
      if (!tracks.length) return null;
      return {
        name: data.name,
        author: data.owner.display_name,
        thumbnail: data.images?.[0]?.url || null,
        id: data.id,
        url: data.external_urls.spotify || `https://open.spotify.com/playlist/${id}`,
        tracks
      };
    } catch (err) {
      return null;
    }
  }
  async getAlbum(id) {
    if (!this.clientId || !this.clientSecret) throw new Error("Spotify clientId and clientSecret are required.");
    try {
      const res = await this.fetchData(`${SP_BASE}/albums/${id}${this.market ? `?market=${this.market}` : ""}`);
      if (!res) return null;
      const data = await res.json();
      if (!data.tracks.items.length) return null;
      const t = data.tracks.items;
      let next = data.tracks.next;
      while (typeof next === "string") {
        try {
          const nextRes = await this.fetchData(next);
          if (!nextRes) break;
          const nextPage = await nextRes.json();
          t.push(...nextPage.items);
          next = nextPage.next;
          if (!next) break;
        } catch {
          break;
        }
      }
      const tracks = t.filter((m) => m?.name && m?.artists).map((m) => ({
        name: m.name,
        duration_ms: m.duration_ms,
        artists: m.artists,
        external_urls: m.external_urls,
        id: m.id,
        album: {
          images: data.images || []
        }
      }));
      if (!tracks.length) return null;
      return {
        name: data.name,
        author: data.artists.map((m) => m.name).join(", "),
        thumbnail: data.images?.[0]?.url || null,
        id: data.id,
        url: data.external_urls.spotify || `https://open.spotify.com/album/${id}`,
        tracks
      };
    } catch {
      return null;
    }
  }
  async getTrack(id) {
    try {
      const res = await this.fetchData(`${SP_BASE}/tracks/${id}${this.market ? `?market=${this.market}` : ""}`);
      if (!res) return null;
      const track = await res.json();
      return {
        name: track.name,
        duration_ms: track.duration_ms,
        artists: track.artists,
        external_urls: track.external_urls,
        id: track.id,
        album: {
          images: track.album.images
        }
      };
    } catch {
      return null;
    }
  }
  async getRecommendations(trackIds, limit) {
    try {
      if (this.useCredentials) throw new Error("getRecommendations endpoint is not supported when using credentials.");
      const res = await this.fetchData(
        `${SP_BASE}/recommendations/?seed_tracks=${trackIds.join(",")}&limit=${limit || "100"}${this.market ? `&market=${this.market}` : ""}`
      );
      if (!res) return null;
      const data = await res.json();
      return data.tracks.map((m) => ({
        title: m.name,
        duration: m.duration_ms,
        artist: m.artists.map((artist) => artist.name).join(", "),
        url: m.external_urls?.spotify || `https://open.spotify.com/track/${m.id}`,
        thumbnail: m.album.images?.[0]?.url || null
      }));
    } catch {
      return null;
    }
  }
  buildTokenUrl() {
    const baseUrl = new URL("https://open.spotify.com/get_access_token");
    baseUrl.searchParams.set("reason", "init");
    baseUrl.searchParams.set("productType", "web-player");
    return baseUrl;
  }
  calculateToken(hex) {
    const token = hex.map((v, i) => v ^ i % 33 + 9);
    const bufferToken = Buffer.from(token.join(""), "utf8").toString("hex");
    return Secret.fromHex(bufferToken);
  }
  async getAccessTokenUrl() {
    if (this.useCredentials) return "https://accounts.spotify.com/api/token?grant_type=client_credentials";
    const token = this.calculateToken([12, 56, 76, 33, 88, 44, 88, 33, 78, 78, 11, 66, 22, 22, 55, 69, 54]);
    const spotifyHtml = await fetch("https://open.spotify.com", {
      headers: {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36"
      }
    }).then((v) => v.text());
    const root = parse(spotifyHtml);
    const scriptTags = root.querySelectorAll("script");
    const playerSrc = scriptTags.find((v) => v.getAttribute("src")?.includes("web-player/web-player."))?.getAttribute("src");
    if (!playerSrc) throw new Error("Could not find player script source");
    const playerScript = await fetch(playerSrc, {
      headers: {
        Dnt: "1",
        Referer: "https://open.spotify.com/",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36"
      }
    }).then((v) => v.text());
    const playerVerSplit = playerScript.split("buildVer");
    const versionString = `{"buildVer"${playerVerSplit[1].split("}")[0].replace("buildDate", '"buildDate"')}}`;
    const version = JSON.parse(versionString);
    const url = this.buildTokenUrl();
    const { searchParams } = url;
    const cTime = Date.now();
    const sTime = await fetch("https://open.spotify.com/server-time", {
      headers: {
        Referer: "https://open.spotify.com/",
        Origin: "https://open.spotify.com"
      }
    }).then((v) => v.json()).then((v) => v.serverTime);
    const totp = new TOTP({
      secret: token,
      period: 30,
      digits: 6,
      algorithm: "SHA1"
    });
    const totpServer = totp.generate({
      timestamp: sTime * 1e3
    });
    const totpClient = totp.generate({
      timestamp: cTime
    });
    searchParams.set("sTime", String(sTime));
    searchParams.set("cTime", String(cTime));
    searchParams.set("totp", totpClient);
    searchParams.set("totpServer", totpServer);
    searchParams.set("totpVer", "5");
    searchParams.set("buildVer", version.buildVer);
    searchParams.set("buildDate", version.buildDate);
    return url;
  }
};

// src/SpotifyExtractor.ts
var SpotifyExtractor = class extends BaseExtractor {
  constructor() {
    super(...arguments);
    this._credentials = {
      clientId: this.options.clientId || process.env.DP_SPOTIFY_CLIENT_ID || "",
      clientSecret: this.options.clientSecret || process.env.DP_SPOTIFY_CLIENT_SECRET || ""
    };
    this._market = this.options.market || market;
    this.internal = new SpotifyAPI({ ...this._credentials, market: this._market });
  }
  async activate() {
    this.protocols = ["spsearch", "spotify"];
    const fn = this.options.createStream;
    if (typeof fn === "function") {
      this._stream = (q) => {
        return fn(this, q);
      };
    }
  }
  async deactivate() {
    this._stream = void 0;
    this.protocols = [];
  }
  async validate(query) {
    return !isUrl(query) || [spotifyAlbumRegex, spotifyPlaylistRegex, spotifySongRegex].some((regex) => regex.test(query));
  }
  buildTrack(trackInfo, requestedBy, playlist) {
    return new Track(this.context.player, {
      title: trackInfo.name || trackInfo.title,
      description: `${trackInfo.name || trackInfo.title} by ${Array.isArray(trackInfo.artists) ? trackInfo.artists.map((m) => m.name).join(", ") : trackInfo.artist || "Unknown Artist"}`,
      author: Array.isArray(trackInfo.artists) ? trackInfo.artists[0]?.name : trackInfo.artist || "Unknown Artist",
      url: trackInfo.external_urls?.spotify || trackInfo.url || `https://open.spotify.com/track/${trackInfo.id}`,
      thumbnail: trackInfo.album?.images?.[0]?.url || trackInfo.thumbnail || "https://www.scdn.co/i/_global/twitter_card-default.jpg",
      duration: Util.buildTimeCode(Util.parseMS(trackInfo.duration_ms || trackInfo.duration || 0)),
      views: 0,
      requestedBy,
      source: "spotify",
      metadata: {
        source: trackInfo,
        bridge: null
      },
      requestMetadata: async () => ({
        source: trackInfo,
        bridge: null
      }),
      playlist
    });
  }
  buildPlaylist(data, context, type = "playlist") {
    const playlist = new Playlist(this.context.player, {
      title: data.name,
      description: "",
      thumbnail: data.thumbnail,
      type,
      source: "spotify",
      author: {
        name: data.author,
        url: null
      },
      tracks: [],
      id: data.id,
      url: data.url,
      rawPlaylist: data
    });
    playlist.tracks = (data.tracks || []).map((trackData) => {
      const track = new Track(this.context.player, {
        title: trackData.name,
        description: `${trackData.name} by ${trackData.artists.map((a) => a.name).join(", ")}`,
        author: trackData.artists[0].name,
        url: trackData.external_urls.spotify,
        thumbnail: trackData.album?.images?.[0]?.url || "https://www.scdn.co/i/_global/twitter_card-default.jpg",
        duration: Util.buildTimeCode(Util.parseMS(trackData.duration_ms)),
        views: 0,
        requestedBy: context.requestedBy,
        source: "spotify",
        metadata: {
          source: trackData,
          bridge: null
        },
        requestMetadata: async () => ({
          source: trackData,
          bridge: null
        }),
        playlist
      });
      track.extractor = this;
      return track;
    });
    return playlist;
  }
  async handle(query, context) {
    const { id } = parseSpotifyUrl(query);
    if (spotifySongRegex.test(query)) {
      const spotifyData = await this.internal.getTrack(id);
      if (!spotifyData) return this.createResponse();
      const track = this.buildTrack(spotifyData, context?.requestedBy);
      track.extractor = this;
      return this.createResponse(null, [track]);
    }
    if (spotifyPlaylistRegex.test(query)) {
      const spotifyPlaylist = await this.internal.getPlaylist(id);
      if (!spotifyPlaylist) return this.createResponse();
      const playlist = this.buildPlaylist(spotifyPlaylist, context, "playlist");
      return this.createResponse(playlist, playlist.tracks);
    }
    if (spotifyAlbumRegex.test(query)) {
      const spotifyAlbum = await this.internal.getAlbum(id);
      if (!spotifyAlbum) return this.createResponse();
      const playlist = this.buildPlaylist(spotifyAlbum, context, "album");
      return this.createResponse(playlist, playlist.tracks);
    }
    const data = await this.internal.search(query);
    if (!data) return this.createResponse();
    return this.createResponse(
      null,
      data.map((spotifyData) => {
        const track = this.buildTrack(spotifyData, context.requestedBy);
        track.extractor = this;
        return track;
      })
    );
  }
  async stream(info) {
    if (this._stream) {
      const stream = await this._stream(info.url, info);
      return stream;
    }
    const result = await this.context.requestBridge(info, this);
    if (!result?.result) throw new Error("Could not bridge this track");
    return result.result;
  }
  async getRelatedTracks(track, history) {
    let relatedTracks = null;
    if (!this.internal.useCredentials) {
      const trackIds = Array.from(
        new Set(
          history.tracks.toArray().filter((t) => t.url.includes("spotify.com")).slice(0, 25).map((t) => {
            const lastSegment = t.url.split("/").at(-1);
            return lastSegment ? lastSegment.split("?").at(0) : null;
          }).filter((id) => id !== null)
        )
      ).sort(() => 0.5 - Math.random()).slice(0, 5);
      if (trackIds.length)
        relatedTracks = await this.internal.getRecommendations(trackIds);
    }
    if (this.internal.useCredentials || !relatedTracks?.length) {
      const artist = Array.from(
        new Set(
          history.tracks.toArray().filter((t) => t.author && !["unknown artist", "unknown"].includes(t.author.toLowerCase())).slice(0, 25).flatMap((t) => t.author.split(",").map((author) => author.trim()))
        )
      ).sort(() => 0.5 - Math.random()).slice(0, 1);
      if (artist)
        relatedTracks = await this.internal.search(`artist:${artist}`);
    }
    if (!relatedTracks?.length) {
      this.context.player.debug("Unable to fetch related tracks");
      return this.createResponse();
    }
    return this.createResponse(
      null,
      relatedTracks.filter(
        (spotifyData) => !Array.from(new Set(history.tracks.toArray())).slice(0, relatedTracks.length).some((t) => t.url === spotifyData.url)
      ).map((spotifyData) => {
        const t = this.buildTrack(spotifyData, track.requestedBy);
        t.extractor = this;
        return t;
      })
    );
  }
};
SpotifyExtractor.identifier = "com.discord-player.spotifyextractor";
export {
  SpotifyExtractor,
  parseSpotifyUrl
};
